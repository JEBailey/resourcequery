/*
 * Copyright 2016 Jason E Bailey
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
options
{
  LOOKAHEAD= 1;

  CHOICE_AMBIGUITY_CHECK = 3;
  OTHER_AMBIGUITY_CHECK = 2;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
}

PARSER_BEGIN(Parser)
package com.sas.sling.resource.parser;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.sas.sling.resource.parser.node.*;
import com.sas.sling.resource.parser.predicates.*;

public final class Parser
{
  private NodesFactory factory;

  public Parser(InputStream stream, String encoding, NodesFactory factory)
  {
    this (stream, encoding);
    this.factory = factory;
  }

  private String unescape(String s)
  {
    if (s.indexOf('\\') < 0)
    {
      return s;
    }

    final StringBuilder sb = new StringBuilder(s.length());
    for (int i = 0; i < s.length(); i++)
    {
      if (s.charAt(i) == '\\')
      {
        i++;
      }
      if (i < s.length())
      {
        sb.append(s.charAt(i));
      }
    }
    return sb.toString();
  }
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
}

TOKEN :
{
  < #ALPHA : [ "a"-"z", "A"-"Z" ] >
| < #ESCAPED_CHAR : "\\" ~[ ] >
}

TOKEN :
{
  < UNRESERVED_STR : (~[ "\"", "'", "(", ")", ";", ",", "=", "<", ">", "!", "~", " ", "[", "]" ])+ >
| < DOUBLE_QUOTED_STR :
    (
      "\""
      (
        < ESCAPED_CHAR >
      | ~[ "\"", "\\" ]
      )*
      "\""
    ) >
}

TOKEN :
{
  < AND :
    (
      ";"
    | " and "
    ) >
| < OR :
    (
      ","
    | " or "
    ) >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < COMP_ALT :
    (
      ">"
    | "<"
    | "="
    | "!"
    )+ >
}

Node Input() :
{
  final Node node;
}
{
  node = Or() < EOF >
  {
    return node;
  }
}

Node Or() :
{
  final List < Node > nodes = new ArrayList < Node > (3);
  Node node;
}
{
  node = And()
  {
    nodes.add(node);
  }
  (
    < OR > node = And()
    {
      nodes.add(node);
    }
  )*
  {
    return nodes.size() != 1 ? factory.createOrNode(nodes) : nodes.get(0);
  }
}

Node And() :
{
  final List < Node > nodes = new ArrayList < Node > (3);
  Node node;
}
{
  node = Constraint()
  {
    nodes.add(node);
  }
  (
    < AND > node = Constraint()
    {
      nodes.add(node);
    }
  )*
  {
    return nodes.size() != 1 ? factory.createAndNode(nodes) : nodes.get(0);
  }
}

Node Constraint() :
{
  final Node node;
}
{
  (
    LOOKAHEAD(< LPAREN >)
    node = Group()
  | 
    node = Comparison()
  )
  {
    return node;
  }
}

Node Group() :
{
  final Node node;
}
{
  < LPAREN > node = Or() < RPAREN >
  {
    return node;
  }
}

Node Comparison() :
{
  Node sel;
  String op = null;
  List < Node > args;
}
{
  sel = Argument() 
  op = Operator() 
  args = Arguments()
  {
    return factory.createComparisonNode(op, sel, args);
  }
}

String Operator() :
{}
{
  token = < COMP_ALT >
  {
    return token.image;
  }
}

List < Node > Arguments() :
{
  Object value = new ArrayList();
}
{
  (
    < LPAREN > [ value = CommaSepArguments() ] < RPAREN >
  )
  {
    return (List) value;
  }
| 
  value = Argument()
  {
    return Arrays.asList((Node) value);
  }
}

List < Node > CommaSepArguments() :
{
  final List < Node > list = new ArrayList < Node > (3);
  Node arg;
}
{
  arg = Argument()
  {
    list.add(arg);
  }
  (
    < OR > 
    arg = Argument()
    {
      list.add(arg);
    }
  )*
  {
    return list;
  }
}

Node Argument() :
{
  Node selector = null;
  List < Node > children = null;
}
{
  (
    token = < UNRESERVED_STR >
  | token = < DOUBLE_QUOTED_STR >
  )
  {
    selector = factory.createArgument(token.kind, token.image);
  }
  [ children = Arguments() ]
  {
    if (children == null)
    {
      return selector;
    }
    else
    {
      return factory.createFunction(selector, children);
    }
  }
}

Node Property() :
{
}
{
  < LBRACKET >
  {
    return null;
  }
}
